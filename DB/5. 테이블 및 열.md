# 테이블

- 테이블(Table)은 실제 데이터(레코드)를 담기 위해 존재한다.
- 테이블은 반드시 스키마에 속해있어야 한다.
- 명명법: 스네이크 케이스, 복수형(경우에 따라 단수형)

## 생성하기

- 테이블을 만들기 위해 아래 쿼리를 실행한다.
   > ```sql
   > CREATE TABLE `스키마 이름`.`테이블 이름`
   > (
   >     [열 구조,...],
   >     [제약 조건,...]
   > );
   > ```
   > - 소속될 스키마는 반드시 존재해야 한다.
   > - 동일한 스키마 내에서 이미 사용 중인 테이블 이름은 사용할 수 없다.

### 기본키 제약 조건 (Primary Key Constraint)
- 기본키가 되는 한 개 이상의 열(들)은 해당 테이블의 가장 기준이 되는 열(들)을 의미한다.
- 기본키로 지정된 열(들)이 가지는 값에 대해서 레코드들은 중복되는 값을 가질 수 없다.
- 하나의 테이블은 기본키를 가지지 않거나 하나의 기본키만 가질 수 있다. 하나의 기본키가 여러 개의 열을 가질 수는 있지만 여러 개의 기본키가 존재할 수는 없다.
- 기본키의 대상이 되는 열은 `NULL`을 허용할 수 없음으로, 해당 열은 `NOT NULL`이어야 한다.
- 기본키를 선언하려면 아래와 같이 제약 조건을 작성한다.
   > ```mariadb
   > CONSTRAINT PRIMARY KEY ([`열 이름`,...])
   > ```

### 외래키 제약 조건 (Foreign Key Constraint)
- 외래키 제약 조건이 적용되는 열이 가지는 레코드의 값을 참조 대상인(Referencing) 테이블의 열이 가지는 레코드의 값으로 제한하기 위해 사용하는 제약 조건이다.
- 참고 대상이 되는 열은 기본키 이거나 유니크여야 한다.
- 외래키를 적용하고 있는 열과 참고 대상인 열의 데이터 타입이 같아야 한다.
- 외래키를 선언하려면 아래와 같이 제약 조건을 작성한다.
   > ```mariadb
   > CONSTRAINT FOREIGN KEY ([`열 이름`,...]) REFERENCES `참고 대상 스키마`.`참고 대상 테이블` ([`참고 대상 열`,...])
   >     [ON DELETE CASCADE]?
   >     [ON UPDATE CASCADE]?
   > ```
   > - `ON DELETE CASCADE` : 참조 대상이 삭제되면 현재 레코드도 같이 삭제되게 한다.
   > - `ON UPDATE CASCADE` : 참조 대상이 수정되면 현재 레코드도 같이 수정되게 한다.

### 유니크 제약 조건 (Unique Key Constraint)
- 유니크로 설정된 열에 해당하는 레코드가 가지는 값은 중복될 수 없다.
- 값이 중복될 수 없다는 부분은 기본키와 같으나, 유니크는 테이블에서 대표성을 띄지 않는다는 점과, 하나의 테이블이 여러 개의 유니크를 가질 수 있다는 점이 다르다.
- 추가로, 기본키는 `NULL`값을 허용하지 않지만, 유니크는 `NULL`값을 허용하며, `NULL`값에 대해서는 중복 검사를 실시하지 않는다.
- 유니크 제약 조건을 선언하려면 아래와 같이 제약 조건을 작성한다.
   > ```mariadb
   > CONSTRAINT UNIQUE ([`열 이름`,...])
   > ```

### 체크 제약 조건 (Check Constraint)
- 체크 제약 조건은 주어진 조건을 만족할 때에만 레코드를 삽입할 수 있게 하기 위해 사용한다.
- 다른 제약 조건과 달리 반드시 어떠한 열에 의존적이지는 않다.
- 체크 제약 조건을 선언하려면 아래와 같이 제약 조건을 작성한다.
   > ```mariadb
   > CONSTRAINT CHECK ([조건])
   > ```

## 조회하기

- 존재하는 스키마에 소속되어 있는 테이블의 목록을 조회하기 위해 아래 쿼리를 실행한다.
   > ```mariadb
   > SHOW TABLES IN `스키마 이름`;
   > ```

- 존재하는 테이블이 가지고 있는 열의 구조를 조회하기 위해 아래 쿼리를 실행한다.
   > ```mariadb
   > DESC `스키마 이름`.`테이블 이름`;
   > ```

## 수정하기

### 이름 및 소속 스키마 변경하기

- 테이블의 이름을 변경하거나, 소속된 스키마를 변경하고자 할 때 아래 쿼리를 실행한다.
- 스키마의 이름을 변경하는 것은 불가능함으로 아래 쿼리를 이용하여 테이블의 소속 스키마 전체를 변경하고, 기존의 스키마를 삭제하는 방식으로 스키마를 이동해야 한다.
   > ```mariadb
   > ALTER TABLE `기존 스키마 이름`.`기존 테이블 이름` RENAME `새로운 스키마 이름`.`새로운 테이블 이름`;
   > ```
   > - 소속 스키마 변경 없이 테이블 이름만 변경하고자 한다면, **기존 스키마 이름**과 **새로운 스키마 이름**을 동일하게 유지하면 된다.
   > - 테이블 이름 변경 없이 소속 스키마만 변경하고자 한다면, **기존 테이블 이름**과 **새로운 테이블 이름**을 동일하게 유지하면 된다.

### 열 추가하기

- 존재하는 테이블에 열을 추가하기 위해 아래 쿼리를 실행한다.
   > ```mariadb
   > ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조];
   > ```
   > - 위 쿼리는 열을 테이블의 가장 마지막에 추가한다.
   > - 추가하는 열을 특정 열의 뒤에 추가하려면 아래와 같이 `AFTER` 키워드를 활용한다.
   > ```mariadb
   > ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조] AFTER `기준 열 이름`;
   > ```
   > - 어떠한 열을 기준으로 앞에 열을 추가하는 키워드는 존재하지 않음으로 테이블의 가장 앞 자리에 열을 추가하기 위해 아래와 같이 `FIRST` 키워드를 활용해야 한다.
   > ```mariadb
   > ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조] FIRST;
   > ```

### 열 이름 변경하기

- 존재하는 열의 이름을 변경하기 위해 아래 쿼리를 실행한다.
   > ```mariadb
   > ALTER TABLE `스키마 이름`.`테이블 이름` RENAME COLUMN `기존 열 이름` TO `새로운 열 이름`;
   > ```

### 열 구조 수정하기

- 존재하는 열의 구조를 수정하기 위해 아래 쿼리를 실행한다.
   > ```mariadb
   > ALTER TABLE `스키마 이름`.`테이블 이름` MODIFY COLUMN `대상 열 이름` [이름을 제외한 열 구조];
   > ```
   > - 열 구조 수정과 동시에 `AFTER` 및 `FIRST` 키워드를 사용하여 위치 또한 옮길 수 있다.

### 열 삭제하기

- 존재하는 열을 삭제하기 위해 아래 쿼리를 실행한다.
   > ```mariadb
   > ALTER TABLE `스키마 이름`.`테이블 이름` DROP COLUMN `열 이름`;
   > ```

## 삭제하기

- 테이블을 삭제하기 위해 아래 쿼리를 실행한다.
- 테이블을 삭제하면 이가 가지고 있는 **레코드가 모두 삭제되고 되돌릴 수 없음**으로 유의한다.
   > ```mariadb
   > DROP TABLE `스키마 이름`.`테이블 이름`;
   > ```

# 열

- 열(Column)은 테이블에 존재하는 레코드가 가지는 데이터의 타입을 제한하기 위해 사용한다.
- 명명법: 스네이크 케이스
- **열의 구조**는 아래와 같다.
   > ```mariadb
   > `열 이름` [데이터 타입] [NULL|NOT NULL]? [DEFAULT x]? [AUTO_INCREMENT]?
   > ```
   > - `NULL`: 해당 열의 값이 비어있을 수 있다는 의미이다. 생략시 기본값이다.
   > - `NOT NULL`: 해당 열의 값이 비어있을 수 없다는 의미이다.
   > - `DEFAULT x`: 레코드 삽입시 해당 열의 값을 명시하지 않을 경우 사용할 기본 값을 `x`로 설정한다. 생략시 `x`는 `NULL`이다.
   > - `AUTO_INCREMENT` : 해당 열이 기본키이고 정수형일 때 사용할 수 있고, 레코드 삽입 시 해당 열을 명시하지 않을 경우 `1`부터 시작하여 `1`씩 증가시켜 값을 삽입하겠다는 의미이다. 단, 레코드 삽입 실패시에도 값은 증가하므로 레코드 개수의 의미로 사용하여서는 안 된다.

## 데이터 타입

### 정수형

- 모든 정수형 뒤에 `UNSIGNED` 키워드를 추가하게 되면, 음수부를 포기하고 그 만큼 양수부를 추가로 활용할 수 있게 된다. 가령, `TINYINT UNSIGNED` 타입의 가용 범위는 `0`부터 `255`까지이다.
- `TINYINT`: (1 Byte) `-128`부터 `127`까지의 정수
- `SMALLINT`: (2 Bytes) `-32,768`부터 `32,767`까지의 정수
- `MEDIUMINT`: (3 Bytes) `-8,388,608`부터 `8,388,607`까지의 정수 
- `INT`: (4 Bytes) `-2,147,483,648`부터 `2,147,483,647`까지의 정수
- `BIGINT`: (8 Bytes) `-9,223,372,036,854,775,808`부터 `9,223,372,036,854,775,807`까지의 정수

### 실수형

- `FLOAT`: (4 Bytes) `-3.402823466E+38`부터 `3.402823466E+38`까지의 부동 소수. 값을 저장하는 방식 때문에 오류(오차)가 발생할 수 있어 민감한 데이터를 저장하는데 사용하지 않는다.
- `DOUBLE`: (8 Bytes) `-1.797693134862315157E+308`부터 `1.79769313486231573E+308`까지의 부동 소수. 값을 저장하는 방식 때문에 오류(오차)가 발생할 수 있어 민감한 데이터를 저장하는데 사용하지 않는다.
- `DECIMAL(t, p)`: (`t` Bytes) 전체 길이가 `t`, 소수부 길이가 `p`인 고정 소수. 차지하는 용량이 큰 대신, 값이 유실되지 않는다.

### 문자형

- `VARCHAR(n)`: (최대 `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있고 `n`의 최대 값은 `65,535`이다.
- `TINYTEXT(n)`: (최대 `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있고 `n`의 최대 값은 `255`이다.
- `TEXT(n)`: (최대 `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있고 `n`의 최대 값은 `65,535`이다.
- `MEDIUMTEXT(n)`: (최대 `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있고 `n`의 최대 값은 `16,777,215`이다.
- `LONGTEXT(n)`: (최대 `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있고 `n`의 최대 값은 `4,294,967,295`이다.

### 논리형

- `BOOLEAN`: (1 Byte) 참(`TRUE`)과 거짓(`FALSE`)을 가질 수 있다.

### 날짜 및 시간

- `DATE`: 날짜(년, 월, 일)를 가질 수 있다.
- `TIME` 혹은 `TIME(n)`: 시간(시, 분, 초)를 가질 수 있다. `n`은 밀리초의 길이를 의미하며 생략시 `0`을 기본 값으로 가진다.
- `DATETIME` 혹은 `DATETIME(n)`: 날자 및 시간을 가질 수 있다. `n`은 밀리초의 길이를 의미하며 생략시 `0`을 기본 값으로 가진다.

### 기타

- `TINYBLOB(n)`: (`n` Bytes) 이진 데이터를 담기 위해 사용한다. `n`의 최대 값은 `255`이다.
- `BLOB(n)`: (`n` Bytes) 이진 데이터를 담기 위해 사용한다. `n`의 최대 값은 `65,535`이다.
- `MEDIUMBLOB(n)`: (`n` Bytes) 이진 데이터를 담기 위해 사용한다. `n`의 최대 값은 `16,777,215`이다.
- `LONGBLOB(n)`: (`n` Bytes) 이진 데이터를 담기 위해 사용한다. `n`의 최대 값은 `4,294,967,295`이다.